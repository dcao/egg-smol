;; Implements part of the simplification layer of herbie in egg-smolðŸ«¡

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Datatypes

;; Operators from FPCore
(datatype Math
  ; Ground terms
  (Num Rational)
  (Var String)

  ; Constant-folding ops
  (Add Math Math)
  (Sub Math Math)
  (Mul Math Math)
  (Div Math Math)
  (Pow Math Math)
  (Neg Math)
  (Sqrt Math)
  (Cbrt Math) ; cube root
  (Fabs Math)
  (Ceil Math)
  (Floor Math)
  (Round Math)
  (Log Math))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Analyses
;; --------
;; This example has four analyses:
;; an interval analysis consisting of a hi and lo component,
;; a constant folding analysis, and a nonzero analysis.

(function hi (Math) Rational :merge (min old new))
(function lo (Math) Rational :merge (max old new))
(function evals-to (Math) Rational)
(relation non-zero (Math))

;; First, define our constant folding analysis

; If this expression is constant-foldable, union it with its evaled form
(rule ((= ve (evals-to e)))
      ((union e (Num ve))))

; Cases
(rule ((= e (Num n)))
      ((set (evals-to e) n)))
(rule ((= e (Add a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (+ va vb))))
(rule ((= e (Sub a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (- va vb))))
(rule ((= e (Mul a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (* va vb))))
(rule ((= e (Div a b))
       (= va (evals-to a))
       (= vb (evals-to b))
       (non-zero b))
      ((set (evals-to e) (/ va vb))))
; TODO: pow
(rule ((= e (Neg a))
       (= va (evals-to a)))
      ((set (evals-to e) (neg va))))
; TODO: sqrt
; TODO: cbrt
(rule ((= e (Fabs a))
       (= va (evals-to a)))
      ((set (evals-to e) (abs va))))
(rule ((= e (Ceil a))
       (= va (evals-to a)))
      ((set (evals-to e) (ceil va))))
(rule ((= e (Floor a))
       (= va (evals-to a)))
      ((set (evals-to e) (floor va))))
(rule ((= e (Round a))
       (= va (evals-to a)))
      ((set (evals-to e) (round va))))
; TODO: log

; TODO: do we need "bool" for this?
;; To check if something is zero, we check that zero is not contained in the
;; interval. This is defined as a primitive in the Rational sort rn
(rule ((= l (lo e))
       (= h (hi e))
       (ival-non-zero l h))
      ((non-zero e)))

(rule ((= ve (evals-to e)))
      ((set (lo e) ve)
       (set (hi e) ve)))

;; The interval analyses are similar to the constant-folding analysis,
;; except we have to take the lower/upper bound of the results we get
(rule ((= e (Add a b))
       (= la (lo a))
       (= lb (lo b)))
      ((set (lo e) (+ la lb))))
(rule ((= e (Add a b))
       (= ha (hi a))
       (= hb (hi b)))
      ((set (hi e) (+ ha hb))))
      
(rule ((= e (Sub a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (- la lb) (- la hb))
               (min (- ha lb) (- ha hb))))
       (set (hi e) 
          (max (max (- la lb) (- la hb))
               (max (- ha lb) (- ha hb))))))

(rule ((= e (Mul a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (* la lb) (* la hb))
               (min (* ha lb) (* ha hb))))
       (set (hi e) 
          (max (max (* la lb) (* la hb))
               (max (* ha lb) (* ha hb))))))

(rule ((= e (Div a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b))
       (!= lb (rational 0 1))
       (!= hb (rational 0 1)))
      ((set (lo e) 
          (min (min (/ la lb) (/ la hb))
               (min (/ ha lb) (/ ha hb))))
       (set (hi e) 
          (max (max (/ la lb) (/ la hb))
               (max (/ ha lb) (/ ha hb))))))

; TODO: Pow

(rule ((= e (Neg a))
       (= ha (hi a)))
      ((set (lo e) (neg ha))))
(rule ((= e (Neg a))
       (= la (lo a)))
      ((set (hi e) (neg la))))

; TODO: Sqrt
; TODO: Cbrt

(rule ((= e (Fabs a))
       (= la (lo a))
       (= ha (hi a)))
      ((set (lo e) (min (abs la) (abs ha)))))
(rule ((= e (Fabs a))
       (= la (lo a))
       (= ha (hi a)))
      ((set (hi e) (max (abs la) (abs ha)))))

; TODO: Ceil
; TODO: Floor
; TODO: Round
; TODO: Log

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Rewrites

(rewrite (Mul a (Div b c)) (Div (Mul a b) c))
(rewrite (Div a (Mul b c)) (Div (Div a b) c))
(rewrite (Div (Mul b c) a) (Div b (Div a c)) :when ((non-zero c)))

(rewrite (Sub a (Mul b c))       (Add a (Mul (Neg b) c)))

(rewrite (Div x x) (Num (rational 1 1))
         :when ((non-zero x)))

(rewrite (Div x y) (Mul x (Div (Num (rational 1 1)) y)))
(rewrite (Div x y) (Div (Num (rational 1 1)) (Div y x))
  :when ((non-zero x)
         (non-zero y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Testing
;; -------
;; In actuality, herbie would be responsible for plugging exprs in here.
;; For testing purposes we just come up with some example test cases

;; Test 1: zero-check
(define one (Num (rational 1 1)))

(define x (Var "x"))
(set (lo x) (rational 0 1))
(set (hi x) (rational 100 1))

(define e (Div one (Add x one)))

; Works fine
(run 5)
(check (non-zero e))

; Should also work - didn't before
(run 1)
(check (non-zero e))
