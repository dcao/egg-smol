;; Implements part of the simplification layer of herbie in egg-smolðŸ«¡

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Datatypes

;; Operators from FPCore
(datatype Math
  ; Ground terms
  (Num Rational)
  (Var String)

  ; Constant-folding ops
  (Add Math Math)
  (Sub Math Math)
  (Mul Math Math)
  (Div Math Math)
  (Pow Math Math)
  (Neg Math)
  (Sqrt Math)
  (Cbrt Math) ; cube root
  (Fabs Math)
  (Ceil Math)
  (Floor Math)
  (Round Math)
  (Log Math))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Analyses
;; --------
;; This example has four analyses:
;; an interval analysis consisting of a hi and lo component,
;; a constant folding analysis, and a nonzero analysis.

(function hi (Math) Rational :merge (min old new))
(function lo (Math) Rational :merge (max old new))
(function evals-to (Math) Rational)
(relation non-zero (Math))

;; First, define our constant folding analysis

; If this expression is constant-foldable, union it with its evaled form
(rule ((= ve (evals-to e)))
      ((union e (Num ve))))

; Cases
(rule ((= e (Num n)))
      ((set (evals-to e) n)))
(rule ((= e (Add a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (+ va vb))))
(rule ((= e (Sub a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (- va vb))))
(rule ((= e (Mul a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (* va vb))))
(rule ((= e (Div a b))
       (= va (evals-to a))
       (= vb (evals-to b))
       (non-zero b))
      ((set (evals-to e) (/ va vb))))
; TODO: pow
(rule ((= e (Neg a))
       (= va (evals-to a)))
      ((set (evals-to e) (neg va))))
; TODO: sqrt
; TODO: cbrt
(rule ((= e (Fabs a))
       (= va (evals-to a)))
      ((set (evals-to e) (abs va))))
(rule ((= e (Ceil a))
       (= va (evals-to a)))
      ((set (evals-to e) (ceil va))))
(rule ((= e (Floor a))
       (= va (evals-to a)))
      ((set (evals-to e) (floor va))))
(rule ((= e (Round a))
       (= va (evals-to a)))
      ((set (evals-to e) (round va))))
; TODO: log

; TODO: do we need "bool" for this?
;; To check if something is zero, we check that zero is not contained in the
;; interval. This is defined as a primitive in the Rational sort rn
(rule ((= l (lo e))
       (= h (hi e))
       (ival-non-zero l h))
      ((non-zero e)))

(rule ((= ve (evals-to e)))
      ((set (lo e) ve)
       (set (hi e) ve)))

;; The interval analyses are similar to the constant-folding analysis,
;; except we have to take the lower/upper bound of the results we get
(rule ((= e (Add a b))
       (= la (lo a))
       (= lb (lo b)))
      ((set (lo e) (+ la lb))))
(rule ((= e (Add a b))
       (= ha (hi a))
       (= hb (hi b)))
      ((set (hi e) (+ ha hb))))
      
(rule ((= e (Sub a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (- la lb) (- la hb))
               (min (- ha lb) (- ha hb))))
       (set (hi e) 
          (max (max (- la lb) (- la hb))
               (max (- ha lb) (- ha hb))))))

(rule ((= e (Mul a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (* la lb) (* la hb))
               (min (* ha lb) (* ha hb))))
       (set (hi e) 
          (max (max (* la lb) (* la hb))
               (max (* ha lb) (* ha hb))))))

(rule ((= e (Div a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b))
       (!= lb (rational 0 1))
       (!= hb (rational 0 1)))
      ((set (lo e) 
          (min (min (/ la lb) (/ la hb))
               (min (/ ha lb) (/ ha hb))))
       (set (hi e) 
          (max (max (/ la lb) (/ la hb))
               (max (/ ha lb) (/ ha hb))))))

; TODO: Pow

(rule ((= e (Neg a))
       (= ha (hi a)))
      ((set (lo e) (neg ha))))
(rule ((= e (Neg a))
       (= la (lo a)))
      ((set (hi e) (neg la))))

; TODO: Sqrt
; TODO: Cbrt

(rule ((= e (Fabs a))
       (= la (lo a))
       (= ha (hi a)))
      ((set (lo e) (min (abs la) (abs ha)))))
(rule ((= e (Fabs a))
       (= la (lo a))
       (= ha (hi a)))
      ((set (hi e) (max (abs la) (abs ha)))))

; TODO: Ceil
; TODO: Floor
; TODO: Round
; TODO: Log

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Rewrites

;; Commutativity
(rewrite (Add a b) (Add b a))
(rewrite (Mul a b) (Mul b a))

;; Associativity
(rewrite (Add a (Add b c)) (Add (Add a b) c))
(rewrite (Add (Add a b) c) (Add a (Add b c)))
(rewrite (Add a (Sub b c)) (Sub (Add a b) c))
(rewrite (Add (Sub a b) c) (Sub a (Sub b c)))
(rewrite (Sub a (Add b c)) (Sub (Sub a b) c))
(rewrite (Sub (Add a b) c) (Add a (Sub b c)))
(rewrite (Sub (Sub a b) c) (Sub a (Add b c)))
(rewrite (Sub a (Sub b c)) (Add (Sub a b) c))
(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))
(rewrite (Mul (Mul a b) c) (Mul a (Mul b c)))
(rewrite (Mul a (Div b c)) (Div (Mul a b) c))
(rewrite (Mul (Div a b) c) (Div (Mul a c) b))
(rewrite (Div a (Mul b c)) (Div (Div a b) c))
(rewrite (Div (Mul b c) a) (Div b (Div a c)) :when ((non-zero c)))
(rewrite (Div a (Div b c)) (Mul (Div a b) c) :when ((non-zero c)))
(rewrite (Div (Div b c) a) (Div b (Mul a c)) :when ((non-zero a)))

;; Counting
(rewrite (Add x x) (Mul (Num (rational 2 1)) x))

;; Distributivity
(rewrite (Mul a (Add b c))         (Add (Mul a b) (Mul a c)))
(rewrite (Mul a (Add b c))         (Add (Mul b a) (Mul c a)))
(rewrite (Add (Mul a b) (Mul a c)) (Mul a (Add b c)))
(rewrite (Sub (Mul a b) (Mul a c)) (Mul a (Sub b c)))
(rewrite (Add (Mul b a) (Mul c a)) (Mul a (Add b c)))
(rewrite (Sub (Mul b a) (Mul c a)) (Mul a (Sub b c)))
(rewrite (Add (Mul b a) a)         (Mul (Add b 1) a))
(rewrite (Add a (Mul c a))         (Mul (Add c 1) a))

(rewrite (Neg (Mul a b))       (Mul (Neg a) b))
(rewrite (Neg (Mul a b))       (Mul a (Neg b)))
(rewrite (Mul (Neg a) b)       (Neg (Mul a b)))
(rewrite (Mul a (Neg b))       (Neg (Mul a b)))
(rewrite (Neg (Add a b))       (Add (Neg a) (Neg b)))
(rewrite (Add (Neg a) (Neg b)) (Neg (Add a b)))
(rewrite (Div (Neg a) b)       (Neg (Div a b)))
(rewrite (Neg (Div a b))       (Div (Neg a) b))

(rewrite (Sub a (Mul (Neg b) c)) (Add a (Mul b c)))
(rewrite (Sub a (Mul b c))       (Add a (Mul (Neg b) c)))

;; TODO: Difference of squares canonicalization

; ;; Identity
; ;; This isn't subsumed by const folding since this can return results
; ;; even if we can't evaluate a precise value for x
; (rewrite (Div (Num (rational 1 1)) (Div (Num (rational 1 1)) x))
;          x
;          :when ((non-zero x)))
; (rewrite (Mul x (Div (Num (rational 1 1)) x))
;          (Num (rational 1 1))
;          :when ((non-zero x)))
; (rewrite (Mul (Div (Num (rational 1 1)) x) x)
;          (Num (rational 1 1))
;          :when ((non-zero x)))
; 
; (rewrite (Sub x x) (Num (rational 0 1)))
; (rewrite (Div x x) (Num (rational 1 1))
;          :when ((non-zero x)))
; (rewrite (Div (Num (rational 0 1)) x) (Num (rational 0 1))
;          :when ((non-zero x)))
; (rewrite (Mul (Num (rational 0 1)) x) (Num (rational 0 1)))
; (rewrite (Mul x (Num (rational 0 1))) (Num (rational 0 1)))
; 
; (rewrite (Add (Num (rational 0 1)) x) x)
; (rewrite (Add x (Num (rational 0 1))) x)
; (rewrite (Sub (Num (rational 0 1)) x) (Neg x))
; (rewrite (Sub x (Num (rational 0 1))) x)
; (rewrite (Neg (Neg x)) x)
; (rewrite (Mul (Num (rational 1 1)) x) x)
; (rewrite (Mul x (Num (rational 1 1))) x)
; (rewrite (Div x (Num (rational 1 1))) x)
; (rewrite (Mul (Num (rational -1 1)) x) (Neg x))
;  
; (rewrite (Sub a b) (Add a (Neg b)))
; (rewrite (Add a (Neg b)) (Sub a b))
; (rewrite (Neg x) (Sub (Num (rational 0 1)) x))
; (rewrite (Neg x) (Mul (Num (rational -1 1)) x))

; (rewrite (Div x y) (Mul x (Div (Num (rational 1 1)) y)))
; (rewrite (Mul x (Div (Num (rational 1 1)) y)) (Div x y))
; (rewrite (Div x y) (Div (Num (rational 1 1)) (Div y x))
;   :when ((non-zero x)
;          (non-zero y)))
; doesn't work
; (rewrite x (Mul (Num (rational 1 1)) x))

;; TODO: Fractions
;; TODO: Square root
;; TODO: Cube root
;; TODO: Exponentials
;; TODO: Powers
;; TODO: Logs
;; TODO: Trig
;; TODO: Misc.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Testing
;; -------
;; In actuality, herbie would be responsible for plugging exprs in here.
;; For testing purposes we just come up with some example test cases

;; Test 1: zero-check
(define one (Num (rational 1 1)))

(define x (Var "x"))
(set (lo x) (rational 0 1))
(set (hi x) (rational 100 1))

(define e (Div one (Add x one)))

(run 5)
(check (non-zero e))

; should break:
; (check (non-zero (Div one x)))

;; Test 2: const eval
(define ten-e (Mul (Num (rational 5 1)) (Num (rational 2 1))))
(run 6)
(extract ten-e)

;; Test 3: simplification
; (define y (Var "y"))
; (set (lo y) (rational 1 1))
; (set (hi y) (rational 100 1))

; (define e2 (Sub y y))

; (run 3)
; (extract e2)