;; Implements part of the simplification layer of herbie in egg-smolðŸ«¡

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Datatypes

;; Bools!
(datatype B (True) (False))

(function and (B B) B)
(rewrite (and (True) x) x)
(rewrite (and x (True)) x)
(rewrite (and (False) (False)) (False))

;; Operators from FPCore
(datatype Math
  ; Ground terms
  (Num Rational)
  (Var String)

  ; Constant-folding ops
  (Add Math Math)
  (Sub Math Math)
  (Mul Math Math)
  (Div Math Math)
  (Pow Math Math)
  (Neg Math)
  (Sqrt Math)
  (Cbrt Math) ; cube root
  (Fabs Math)
  (Ceil Math)
  (Floor Math)
  (Round Math)
  (Log Math))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Analyses
;; --------
;; This example has four analyses:
;; an interval analysis consisting of a hi and lo component,
;; a constant folding analysis, and a nonzero analysis.

(function hi (Math) Rational :merge (min old new))
(function lo (Math) Rational :merge (max old new))
(function evals-to (Math) Rational)
(function non-zero (Math) B
  :merge (and old new)
  :default (False))

;; First, define our constant folding analysis

; If this expression is constant-foldable, union it with its evaled form
(rule ((= ve (evals-to e)))
      ((union e (Num ve))))

; Cases
(rule ((= e (Num n)))
      ((set (evals-to e) n)))
(rule ((= e (Add a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (+ va vb))))
(rule ((= e (Sub a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (- va vb))))
(rule ((= e (Mul a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (* va vb))))
(rule ((= e (Div a b))
       (= va (evals-to a))
       (= vb (evals-to b))
       ; TODO: this next one only works if Ratios are reduced in ops
       ;       should confirm this
       (!= (rational 0 1) vb))
      ((set (evals-to e) (/ va vb))))
; TODO: pow
(rule ((= e (Neg a))
       (= va (evals-to a)))
      ((set (evals-to e) (neg va))))
; TODO: sqrt
; TODO: cbrt
(rule ((= e (Fabs a))
       (= va (evals-to a)))
      ((set (evals-to e) (abs va))))
(rule ((= e (Ceil a))
       (= va (evals-to a)))
      ((set (evals-to e) (ceil va))))
(rule ((= e (Floor a))
       (= va (evals-to a)))
      ((set (evals-to e) (floor va))))
(rule ((= e (Round a))
       (= va (evals-to a)))
      ((set (evals-to e) (round va))))
; TODO: log

; TODO: do we need "bool" for this?
;; To check if something is zero, we check that zero is not contained in the
;; interval. This is defined as a primitive in the Rational sort rn
(rule ((= l (lo e))
       (= h (hi e))
       (ival-non-zero l h))
      ((set (non-zero e) (True))))

;; The interval analyses are similar to the constant-folding analysis,
;; except we have to take the lower/upper bound of the results we get
(rule ((= e (Add a b))
       (= la (lo a))
       (= lb (lo b)))
      ((set (lo e) (+ la lb))))
(rule ((= e (Add a b))
       (= ha (hi a))
       (= hb (hi b)))
      ((set (hi e) (+ ha hb))))
      
(rule ((= e (Sub a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (- la lb) (- la hb))
               (min (- ha lb) (- ha hb))))))
(rule ((= e (Sub a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (hi e) 
          (max (max (- la lb) (- la hb))
               (max (- ha lb) (- ha hb))))))

(rule ((= e (Mul a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (* la lb) (* la hb))
               (min (* ha lb) (* ha hb))))))
(rule ((= e (Mul a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (hi e) 
          (max (max (* la lb) (* la hb))
               (max (* ha lb) (* ha hb))))))

; TODO: is this right lmao
(rule ((= e (Div a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (/ la lb) (/ la hb))
               (min (/ ha lb) (/ ha hb))))))
(rule ((= e (Div a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (hi e) 
          (max (max (/ la lb) (/ la hb))
               (max (/ ha lb) (/ ha hb))))))

; TODO: Pow

(rule ((= e (Neg a))
       (= ha (hi a)))
      ((set (lo e) (neg ha))))
(rule ((= e (Neg a))
       (= la (lo a)))
      ((set (hi e) (neg la))))

; TODO: Sqrt
; TODO: Cbrt

(rule ((= e (Fabs a))
       (= la (lo a))
       (= ha (hi a)))
      ((set (lo e) (min (abs la) (abs ha)))))
(rule ((= e (Fabs a))
       (= la (lo a))
       (= ha (hi a)))
      ((set (hi e) (max (abs la) (abs ha)))))

; TODO: Ceil
; TODO: Floor
; TODO: Round
; TODO: Log

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Rewrites

;; Commutativity
(rewrite (Add a b) (Add b a))
(rewrite (Mul a b) (Mul b a))

;; Associativity
(rewrite (Add a (Add b c)) (Add (Add a b) c))
(rewrite (Add (Add a b) c) (Add a (Add b c)))
(rewrite (Add a (Sub b c)) (Sub (Add a b) c))
(rewrite (Add (Sub a b) c) (Sub a (Sub b c)))
(rewrite (Sub a (Add b c)) (Sub (Sub a b) c))
(rewrite (Sub (Add a b) c) (Add a (Sub b c)))
(rewrite (Sub (Sub a b) c) (Sub a (Add b c)))
(rewrite (Sub a (Sub b c)) (Add (Sub a b) c))
(rewrite (Mul a (Mul b c)) (Mul (Mul a b) c))
(rewrite (Mul (Mul a b) c) (Mul a (Mul b c)))
(rewrite (Mul a (Div b c)) (Div (Mul a b) c))
(rewrite (Mul (Div a b) c) (Div (Mul a c) b))
(rewrite (Div a (Mul b c)) (Div (Div a b) c))
(rewrite (Div (Mul b c) a) (Div b (Div a c)))
(rewrite (Div a (Div b c)) (Mul (Div a b) c))
(rewrite (Div (Div b c) a) (Div b (Mul a c)))

;; Counting
(rewrite (Add x x) (Mul (Num (rational 2 1)) x))

;; TODO: Distributivity (unsafe)
;; TODO: Distributivity
;; TODO: Difference of squares canonicalization (unsafe)
;; TODO: Identity (unsafe)
;; TODO: Identity
;; TODO: Fractions (unsafe)
;; TODO: Square root (unsafe)
;; TODO: Square root
;; TODO: Cube root (unsafe)
;; TODO: Exponentials (unsafe)
;; TODO: Exponentials
;; TODO: Powers (unsafe)
;; TODO: Powers
;; TODO: Logs (unsafe)
;; TODO: Logs
;; TODO: Trig (unsafe)
;; TODO: Trig
;; TODO: Misc.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Testing
;; -------
;; In actuality, herbie would be responsible for plugging exprs in here.
;; For testing purposes we just come up with some example test cases

;; Test 1: zero-check
(define one (Num (rational 1 1)))
(set (lo one) (rational 1 1))
(set (hi one) (rational 1 1))

(define x (Num (rational 2 1)))
(set (lo x) (rational 0 1))
(set (hi x) (rational 100 1))

(define e (Div one (Add x one)))

(run 3)
(extract (lo (Add x one)))
(extract (hi (Add x one)))
(check (= (non-zero (Div one x)) (False)))
(check (= (non-zero e) (True)))