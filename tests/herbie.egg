;; Implements the simplification layer of herbie in egg-smolðŸ«¡

;; Bools!
(datatype B (True) (False))
(function or (B B) B)
(rewrite (or (True) x) (True))
(rewrite (or x (True)) (True))
(rewrite (or (False) (False)) (False))

;; Operators from FPCore
(datatype Math
  ; Ground terms
  (Num Rational)
  (Var String)

  ; Constant-folding ops
  (Add Math Math)
  (Sub Math Math)
  (Mul Math Math)
  (Div Math Math)
  (Pow Math Math)
  (Neg Math)
  (Sqrt Math)
  (Cbrt Math) ; cube root
  (Fabs Math)
  (Ceil Math)
  (Floor Math)
  (Round Math)
  (Log Math))

;; This example has four analyses:
;; an interval analysis consisting of a hi and lo component,
;; a constant folding analysis, and a nonzero analysis
(function hi (Math) Rational :merge (min old new))
(function lo (Math) Rational :merge (max old new))
(function evals-to (Math) Rational)
(function is-zero (Math) B
  :merge (or old new)
  :default (False))

;; First, define our constant folding analysis
(rule ((= e (Num n)))
      ((set (evals-to e) n)))
(rule ((= e (Add a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (+ va vb))))
(rule ((= e (Sub a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (- va vb))))
(rule ((= e (Mul a b))
       (= va (evals-to a))
       (= vb (evals-to b)))
      ((set (evals-to e) (* va vb))))
(rule ((= e (Div a b))
       (= va (evals-to a))
       (= vb (evals-to b))
       ; TODO: this next one only works if Ratios are reduced in ops
       ;       should confirm this
       (!= (rational 0 1) vb))
      ((set (evals-to e) (/ va vb))))
; TODO: pow
(rule ((= e (Neg a))
       (= va (evals-to a)))
      ((set (evals-to e) (neg va))))
; TODO: sqrt
; TODO: cbrt
(rule ((= e (Fabs a))
       (= va (evals-to a)))
      ((set (evals-to e) (abs va))))
(rule ((= e (Ceil a))
       (= va (evals-to a)))
      ((set (evals-to e) (ceil va))))
(rule ((= e (Floor a))
       (= va (evals-to a)))
      ((set (evals-to e) (floor va))))
(rule ((= e (Round a))
       (= va (evals-to a)))
      ((set (evals-to e) (round va))))
; TODO: log

;; To check if something is zero, we just check if it evaluates to zero
(rule ((= (rational 0 1) (evals-to e)))
      ((set (is-zero e) (True))))

;; The interval analyses are similar to the constant-folding analysis,
;; except we have to take the lower/upper bound of the results we get
(rule ((= e (Add a b))
       (= la (lo a))
       (= lb (lo b)))
      ((set (lo e) (+ la lb))))
(rule ((= e (Add a b))
       (= ha (hi a))
       (= hb (hi b)))
      ((set (hi e) (+ ha hb))))
      
(rule ((= e (Sub a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (- la lb) (- la hb))
               (min (- ha lb) (- ha hb))))))
(rule ((= e (Sub a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (hi e) 
          (max (max (- la lb) (- la hb))
               (max (- ha lb) (- ha hb))))))

(rule ((= e (Mul a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (* la lb) (* la hb))
               (min (* ha lb) (* ha hb))))))
(rule ((= e (Mul a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (hi e) 
          (max (max (* la lb) (* la hb))
               (max (* ha lb) (* ha hb))))))

; TODO: is this right lmao
(rule ((= e (Div a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (/ la lb) (/ la hb))
               (min (/ ha lb) (/ ha hb))))))
(rule ((= e (Div a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (hi e) 
          (max (max (/ la lb) (/ la hb))
               (max (/ ha lb) (/ ha hb))))))

; TODO: Pow

(rule ((= e (Neg a))
       (= ha (hi a)))
      ((set (lo e) (neg ha))))
(rule ((= e (Neg a))
       (= la (lo a)))
      ((set (hi e) (neg la))))

; TODO: Sqrt
; TODO: Cbrt

(rule ((= e (Fabs a))
       (= la (lo a))
       (= ha (hi a)))
      ((set (lo e) (min (abs la) (abs ha)))))
(rule ((= e (Fabs a))
       (= la (lo a))
       (= ha (hi a)))
      ((set (hi e) (max (abs la) (abs ha)))))

; TODO: Ceil
; TODO: Floor
; TODO: Round
; TODO: Log

;; TODO: General rewrite rules

;; Test 1: zero-check
(define x (Num (rational 2 1)))
(define e (Sub x x))

(run 25)

(check (= (is-zero e) (True)))

;; Test 2: interval analysis
(define x (Var "x"))
(define e (Mul x x))

(set (lo x) (rational -10 1))
(set (hi x) (rational 10 1))

(run 1)

(check (= (lo e) (rational -100 1)))

(rule ((= mul (Mul a a)))
      ((set (lo mul) (* (lo a) (lo a)))))

(run 1)
(check (= (lo e) (rational 100 1)))

;; testing extraction of rationals
(extract (lo e))